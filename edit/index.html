<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dld 잉 잌게</title>
    <link rel="stylesheet" href="assets/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.7.4/lottie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/icon/all.min.css">
</head>

<body>
    <div class="bg">
    <header>
        <!-- <h1>Local</h1> -->
        <ul>Juhan Kim
            <!-- <li>첫 번째 항목</li>
            <li>두 번째 항목</li> -->
        </ul>
    </header>

    <main>
        
        <section id="home">
            <div id="anim"></div>
            <!---시작-->
            <script type='text/javascript'>
              window.addEventListener('load', () => {
                  document.querySelector('svg').style.height = 'auto';
                  document.querySelector('svg').style.width = '60%';
                  
                  // 이 부분은 기존 SVG 내부 구조를 정의하는 코드이므로 그대로 유지
                  var body_tree = {"id":"2:49", ... }; 
                  
                  // ⬇️ 기존 mousemove 이벤트를 제거하고 모션 센서 권한 요청 함수를 호출합니다.
                  requestMotionSensorPermission(); 
              
                  function parseDigit(str) { 
                      var result = str.match(/(-?\d+(\.\d+)?)/g).map(v => +v); 
                      return { tdeg: result[0], tox: result[1], toy: result[2] }
                  };
                  
                  // ⬇️ 모션 센서 데이터를 처리하여 SVG를 움직이는 함수
                  function MoveBackgroundByMotion(event) {
                      // 베타(beta: X축 회전), 감마(gamma: Y축 회전) 값을 사용합니다.
                      const beta = event.beta;    // 기기의 앞뒤 기울임 (주로 X축 회전에 사용)
                      const gamma = event.gamma;  // 기기의 좌우 기울임 (주로 Y축 회전에 사용)
                      
                      // 민감도 및 변환 범위 설정 (원하는 만큼 조정 가능)
                      const sensitivity = 0.5; // 민감도 (숫자가 클수록 더 많이 움직임)
                      const maxOffset = 30;    // 최대 이동 픽셀
                      
                      // 기울기 값을 기반으로 SVG 이동 및 회전 값 계산
                      // iOS 디바이스에서 gamma와 beta 값의 범위는 보통 -90에서 90 또는 -180에서 180 사이입니다.
                      const offsetX = gamma * sensitivity; 
                      const offsetY = beta * sensitivity;
                      
                      // SVG 요소들을 순회하며 스타일 적용
                      body_tree.children.forEach((elemennt, index) => {
                          var el = document.getElementById(elemennt.svg_node_id);
                          if (elemennt.locked || !el) return;
                          
                          var i = index + 1; // 딜레이/깊이 효과를 위한 인덱스
                          
                          // 깊이에 따라 이동 값에 인덱스를 곱하여 시차 효과를 줍니다 (기존 코드의 offsetX/Y 계산 방식 유지).
                          const finalOffsetX = offsetX * i * 0.5; 
                          const finalOffsetY = offsetY * i * 0.5;
                          
                          // 회전 값 (시차 효과를 위해 인덱스를 곱합니다)
                          const yRot = gamma * -0.5 * i; // 좌우 기울기에 따른 Y축 회전
                          const xRot = beta * 0.5 * i;  // 앞뒤 기울기에 따른 X축 회전
              
                          let {tdeg, tox, toy} = el?.getAttribute('transform')?.match(/rotate\(.*\)/) 
                                                 ? parseDigit(el.getAttribute('transform').match(/rotate\(.*\)/)[0]) 
                                                 : {tdeg: null, tox: null, toy: null};
              
                          el.style.transformOrigin = (tdeg || tox || toy) ? `${tox}px, ${toy}px` : 'center';
                          el.style.transform = `translate(${finalOffsetX}px, ${finalOffsetY}px) ${tdeg ? ` rotate(${tdeg}deg)` : ''} rotateX(${xRot}deg) rotateY(${yRot}deg)`;
                      });
                  }
              
                  // ⬇️ iOS Safari 모션 센서 권한을 요청하는 함수 (iOS 13+ 필수)
                  function requestMotionSensorPermission() {
                      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                          // iOS 13+ 환경
                          DeviceOrientationEvent.requestPermission()
                              .then(permissionState => {
                                  if (permissionState === 'granted') {
                                      // 권한 허용 시 이벤트 리스너 등록
                                      window.addEventListener('deviceorientation', MoveBackgroundByMotion);
                                      console.log('모션 센서 권한 허용됨');
                                  } else {
                                      // 권한 거부 또는 차단 시 처리
                                      console.log('모션 센서 권한이 거부되었습니다.');
                                      alert('모션 센서 기능을 사용하려면 권한이 필요합니다.');
                                  }
                              })
                              .catch(console.error);
                      } else {
                          // 구형 iOS 또는 다른 브라우저 환경 (권한 요청이 필요 없음)
                          window.addEventListener('deviceorientation', MoveBackgroundByMotion);
                          console.log('권한 요청이 필요 없는 환경입니다.');
                      }
                  }
              
              });
              </script>
              
            <!--끝-->
            <div class="bubble">
                <span id="typing"></span>
            </div>
            
            <script>
            new Typed("#typing", {
              strings: ["안녕하세요.","UX/UI 디자이너 김주한입니다.", "이곳은 2014년도 부터의","포트폴리오 아카이브입니다.","선호하시는 탐색방법을 선택해주세요."],
              typeSpeed: 45,
              backSpeed: 0,
              smartBackspace: false,
              fadeOut: true,
            loop: false,
            onComplete: function(self) {
              // 1. 클래스 이름이 'nextBtn'인 모든 요소를 NodeList 형태로 가져옵니다.
              const buttons = document.querySelectorAll('.nextBtn');
              const delayInterval = 500; // 버튼 간 나타날 시간 간격(밀리초, 0.5초)

              // 2. 각 버튼에 순서대로 접근하며 딜레이를 적용합니다.
              buttons.forEach((btn, index) => {
                // index가 0인 첫 번째 버튼은 0ms, index가 1인 두 번째 버튼은 500ms 후에 실행
                const delay = index * delayInterval; 
                
                setTimeout(() => {
                  // opacity를 1로 설정하여 페이드 인 효과를 줍니다.
                  btn.style.opacity = 1;
                }, delay);
              });
            }
          });
          </script>
          <span id="typed"></span>
          <div class="flex row bottom_gap">
            <button class="nextBtn"><div class="row"><i class="fa-solid fa-wand-magic-sparkles"></i>다음</div><span>이건 뭐냐면요 if you wants show view move the first your fingers</span></button>
            <button class="nextBtn">다음</button>
        </div>

        </section>

    </main>


</div>
<footer>
    <p>&copy; 2025 . All rights reserved.</p>
</footer>
</body>
</html>
